export const mapAskModeResponse = (response) => {
    const properties = {
        outputType: "finalState",
        searches: mapSearches(response.searches),
        aggregations: response.aggregations.map((aggregation) => ({
            groupbyProperty: aggregation.groupby_property,
            aggregation: mapPropertyAggregation(aggregation.aggregation),
            filters: aggregation.filters ? mapFilter(aggregation.filters) : undefined,
            collection: aggregation.collection,
        })),
        usage: mapUsage(response.usage),
        totalTime: response.total_time,
        isPartialAnswer: response.is_partial_answer,
        missingInformation: response.missing_information,
        finalAnswer: response.final_answer,
        sources: response.sources ? mapSources(response.sources) : undefined,
    };
    return Object.assign(Object.assign({}, properties), { display: () => display(properties) });
};
const mapSearches = (searches) => searches.map((search) => ({
    query: search.query,
    filters: search.filters ? mapFilter(search.filters) : undefined,
    collection: search.collection,
    sortProperty: search.sort_property
        ? mapQuerySort(search.sort_property)
        : undefined,
}));
const mapQuerySort = (sort) => ({
    propertyName: sort.property_name,
    order: sort.order,
    tieBreak: sort.tie_break ? mapQuerySort(sort.tie_break) : undefined,
});
const mapUsage = (usage) => ({
    modelUnits: usage.model_units,
    usageInPlan: usage.usage_in_plan,
    remainingPlanRequests: usage.remaining_plan_requests,
});
export const mapResponse = (response) => {
    const properties = {
        outputType: "finalState",
        originalQuery: response.original_query,
        collectionNames: response.collection_names,
        searches: response.searches.map((searches) => searches.map((result) => ({
            collection: result.collection,
            queries: result.queries,
            filters: result.filters.map((filter) => filter.map(mapPropertyFilter)),
            filterOperators: result.filter_operators,
        }))),
        aggregations: mapAggregations(response.aggregations),
        usage: {
            requests: response.usage.requests,
            requestTokens: response.usage.request_tokens,
            responseTokens: response.usage.response_tokens,
            totalTokens: response.usage.total_tokens,
            details: response.usage.details,
        },
        totalTime: response.total_time,
        isPartialAnswer: response.is_partial_answer,
        missingInformation: response.missing_information,
        finalAnswer: response.final_answer,
        sources: mapSources(response.sources),
    };
    return Object.assign(Object.assign({}, properties), { display: () => display(properties) });
};
const mapDatePropertyFilter = (filterValue) => {
    if ("exact_timestamp" in filterValue) {
        return {
            exactTimestamp: filterValue.exact_timestamp,
            operator: filterValue.operator,
        };
    }
    else if ("date_from" in filterValue &&
        "date_to" in filterValue &&
        filterValue.date_from != null &&
        filterValue.date_to != null) {
        return {
            dateFrom: filterValue.date_from,
            dateTo: filterValue.date_to,
            inclusiveFrom: filterValue.inclusive_from,
            inclusiveTo: filterValue.inclusive_to,
        };
    }
    else if ("date_from" in filterValue && filterValue.date_from != null) {
        return {
            dateFrom: filterValue.date_from,
            inclusiveFrom: filterValue.inclusive_from,
        };
    }
    else if ("date_to" in filterValue && filterValue.date_to != null) {
        return {
            dateTo: filterValue.date_to,
            inclusiveTo: filterValue.inclusive_to,
        };
    }
    return undefined;
};
const mapFilter = (filter) => multiFilter(filter)
    ? { combine: filter.combine, filters: filter.filters.map(mapFilter) }
    : mapPropertyFilter(filter);
const mapPropertyFilter = (filter) => {
    switch (filter.filter_type) {
        case "integer":
            return {
                filterType: "integer",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "integer_array":
            return {
                filterType: "integerArray",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "text":
            return {
                filterType: "text",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "text_array":
            return {
                filterType: "textArray",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "boolean":
            return {
                filterType: "boolean",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "boolean_array":
            return {
                filterType: "booleanArray",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "date_range":
            const value = mapDatePropertyFilter(filter.value);
            if (!value) {
                return {
                    filterType: "unknown",
                    propertyName: filter.property_name,
                };
            }
            return {
                filterType: "dateRange",
                propertyName: filter.property_name,
                value,
            };
        case "date_array":
            return {
                filterType: "dateArray",
                propertyName: filter.property_name,
                operator: filter.operator,
                value: filter.value,
            };
        case "geo":
            return {
                filterType: "geo",
                propertyName: filter.property_name,
                latitude: filter.latitude,
                longitude: filter.longitude,
                maxDistanceMeters: filter.max_distance_meters,
            };
        case "is_null":
            return {
                filterType: "isNull",
                propertyName: filter.property_name,
                isNull: filter.is_null,
            };
        default:
            return {
                filterType: "unknown",
                propertyName: filter.property_name,
            };
    }
};
const multiFilter = (filter) => "combine" in filter;
const mapAggregations = (aggregations) => aggregations.map((aggregationGroup) => aggregationGroup.map((result) => ({
    collection: result.collection,
    searchQuery: result.search_query,
    groupbyProperty: result.groupby_property,
    aggregations: result.aggregations.map(mapPropertyAggregation),
    filters: result.filters.map(mapPropertyFilter),
})));
const mapPropertyAggregation = (aggregation) => ({
    propertyName: aggregation.property_name,
    metrics: aggregation.metrics,
    topOccurrencesLimit: "top_occurrences_limit" in aggregation
        ? aggregation.top_occurrences_limit
        : undefined,
});
const mapSources = (sources) => sources.map((source) => ({
    objectId: source.object_id,
    collection: source.collection,
}));
const display = (response) => {
    console.log(JSON.stringify(response, undefined, 2));
};
export const mapProgressMessageFromSSE = (sse) => {
    const data = JSON.parse(sse.data);
    if (data.output_type !== "progress_message") {
        throw new Error(`Expected output_type "progress_message", got ${data.output_type}`);
    }
    return {
        outputType: "progressMessage",
        stage: data.stage,
        message: data.message,
        details: data.details,
    };
};
export const mapStreamedTokensFromSSE = (sse) => {
    const data = JSON.parse(sse.data);
    if (data.output_type !== "streamed_tokens") {
        throw new Error(`Expected output_type "streamed_tokens", got ${data.output_type}`);
    }
    return {
        outputType: "streamedTokens",
        delta: data.delta,
    };
};
const mapWeaviateObject = (object) => {
    const metadata = {
        creationTime: object.metadata.creation_time !== null
            ? object.metadata.creation_time
            : undefined,
        updateTime: object.metadata.update_time !== null
            ? object.metadata.update_time
            : undefined,
        distance: object.metadata.distance !== null ? object.metadata.distance : undefined,
        certainty: object.metadata.certainty !== null
            ? object.metadata.certainty
            : undefined,
        score: object.metadata.score !== null ? object.metadata.score : undefined,
        explainScore: object.metadata.explain_score !== null
            ? object.metadata.explain_score
            : undefined,
        rerankScore: object.metadata.rerank_score !== null
            ? object.metadata.rerank_score
            : undefined,
        isConsistent: object.metadata.is_consistent !== null
            ? object.metadata.is_consistent
            : undefined,
    };
    return {
        properties: object.properties,
        metadata,
        references: undefined,
        uuid: object.uuid,
        vectors: object.vector,
        collection: object.collection,
    };
};
export const mapWeviateSearchResults = (response) => ({
    objects: response.objects.map(mapWeaviateObject),
});
export const mapSearchOnlyResponse = (response) => {
    const apiSearches = response.searches;
    const mappedResponse = {
        searches: apiSearches ? mapSearches(apiSearches) : undefined,
        usage: mapUsage(response.usage),
        totalTime: response.total_time,
        searchResults: mapWeviateSearchResults(response.search_results),
    };
    return { mappedResponse, apiSearches };
};
